# CH2 操作系统概述

虚拟化：操作系统将物理（physical）资源（如处理器、内存或磁盘）转换为更通用、更 强大且更易于使用的虚拟形式。

系统调用：操作系统提供给应用程序供其进行关键操作

操作系统三大要素：**虚拟化，并发，持久性**

操作系统发展：批处理（人工分批运行）->多道程序

# CH3 虚拟化：进程

时分共享CPU：用户同时运行多个并发进程，各个进程依次占用CPU，形成同时运行的假象

## 进程

进程：操作系统为正在运行的程序提供的抽象，是对正在运行的程序的状态的描述

机器状态：程序正在运行时可以读取或者更新的内容，重要的组成部分是其可以访问的内存（地址空间），次重要的部分是寄存器（PC, IP, SP）

## 进程API

主要功能：创建进程，销毁进程，等待进程，其他机制，进程状态

## 进程的创建

1. 将原来存放在磁盘或者闪存SSD的代码和静态数据加载到内存当中，以便CPU直接读取运行。现代操作系统只会在程序执行期间加载需要的代码和数据
2. 操作系统为程序的运行时栈分配内存，这些运行时内存用于存储程序运行期间产生的变量和内存消耗。初始化好栈后，操作系统可能会把一些参数提前填入栈，比如argv, argc
3. 执行初始化任务，设置文件描述符以I/O
4. 启动程序，操作系统将CPU的控制权转移到进程

## 进程状态

### 简单状态

1. 运行：进程正在CPU上执行指令
2. 就绪：进程已经准备好运行，但操作系统没有选择运行进程。
3. 阻塞：进程执行了某些操作（如I/O），导致操作系统置其为阻塞态，以便将CPU资源腾出供其他进程使用。阻塞态进程想重新运行，需要先转入就绪态，再由OS调度转入运行态

![image-20240403104519148](./assets/image-20240403104519148-1712112321131-3.png)

### 可能的额外状态

4. 初始状态（Initial）：进程刚被创建的状态，操作系统只为进程分配了进程控制块PCB，也就是分配了PID，状态，权限。进程的所需资源还没有准备就绪，此时操作系统正在给进程分配所需的资源。
5. 终止状态（僵尸状态，zombie）：进程完成后的状态，代表进程已经完成或出现错误，这个状态设置的目的是为了父进程或操作系统检查进程是否执行完毕，从而方便地清理进程占用的资源。
    父进程通过子进程的终止状态清理子进程，若父进程没有清理子进程，操作系统会在父进程结束的时候检查僵尸子进程，并由操作系统systemd或init负责清理僵尸。父进程本身也会通过其终止状态供操作系统systemd或init清理其资源。



# CH7 进程调度

三个基本问题：

1. 如何开发调度策略基本框架？
2. 什么是关键假设？
3. 调度策略重要指标有哪些？

## （1）工作负载假设

1. 每个工作运行相同时间
2. 所有工作同时交付操作系统（没有新的进程在运行中产生）
3. 一旦开始，所有工作保持到完成（不会被中断或暂停）
4. 所有工作只占用 CPU
5. 每个工作运行时间已知（不考虑进程执行时间的不确定性）

## （2）调度指标

T~周转时间~ = T~完成时间~ - T~到达时间~

## （3）先进先出策略（FIFO）或先进先服务（FCFS）

![image-20240401094544374](./assets/image-20240401094544374-1711935947690-1.png)

7.1：T~平均周转时间~ = (10 + 20 + 30) / 3 = 20
7.2：T~平均周转时间~ = (100 + 110 + 120) / 3 = 110

7.2产生了护航效应（convoy effect）
为了应对7.2的情况，可以采用最短任务优先原则（SJF，short job first）

## （4）最短任务优先（SJF，short job first）

核心：先运行最短的任务，然后是次短的任务，如此下去。

是一种非抢占式调度程序。

抢占式/非抢占式调度程序：
非抢占式调度，会将每一项已经开始执行的任务做完，再考虑是否进行下一项工作
抢占式调度，会将一个进程停止以运行另一个进程，有上下文切换，可以临时停止一个运行进程，并恢复另一个进程

![image-20240403102006655](./assets/image-20240403102006655-1712110809232-1.png)

可能导致的问题：若假设二不成立，后到达的短任务也有可能要等待先到达的长任务结束后才可以执行

## （5）最短完成时间优先（STCF，short time complete first）

是一种抢占式调度程序。

根据工作的剩余时间来排序。比较新程序的剩余时间和正在运行的程序的剩余时间，若新任务的剩余时间小于正在运行的程序，则新任务抢占正在运行的程序开始运行。

可以很好解决7.4的问题

## （6）新指标：响应时间

T~响应时间~ = T~首次运行~ - T~到达时间~

7.3响应时间：A20，B0，C10

7.4响应时间：A0，B90，C100

## （7）轮转调度（RR，round-robin）

核心思想：对计算机时间进行时间切片，RR在每个时间片（调度量子）内运行一个工作，然后在下个时间片切换到下一个任务

**时间片必须是时钟中断周期的倍数**

时间片需要合适：太短导致频繁的上下文切换会影响整体的性能，稍微长一些可以摊销上下文切换成本

RR调度会显著增加周转时间，减小响应时间。
RR是一个倾向于公平的调度策略

## （8）结合I/O的调度

查看CH3-进程状态

调度程序在I/O发起时需要决定进程阻塞后执行哪个新进程，在I/O结束的时候需要决定阻塞的进程什么时候从就绪态转为运行态

![image-20240403111754491](./assets/image-20240403111754491-1712114275938-5.png)

采用STCF策略时，可以采用右图的策略，即把单次CPU使用视为一个任务（从CPU运行到I/O中断）

## （9）预知性

糟糕的是，操作系统往往不知道一个进程真实运行的长度。

因此需要构建一个调度程序，用最近的历史预测未来，称为**多级反馈机制**

# CH8 调度：多级反馈队列

多级反馈队列（MLFQ, multi-level feedback queue）首次提出于CTSS系统，核心是在运行过程中学习进程的特征，从而做出更好的调度决策

## （1）基本规则

MLFQ拥有许多优先级不同的队列，一个工作只能存在一个队列里面。MLFQ总是执行优先级高的队列的工作。

对于同一个队列的不同工作采用RR策略

频繁放弃CPU调用I/O的工作（交互型工作）：高优先级
长时占用CPU（非交互型工作）：低优先级

**规则：**
**规则1. 若优先级A > B，执行A而不执行B（A在更高的优先级队列）**
**规则2. 若优先级A=B，以RR策略运行A和B**

MLFQ核心思想：如果不知道工作是短工 作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短 工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长 工作了。通过这种方式，MLFQ 近似于 SJF。

**规则3. 工作进入系统时，放在最高优先级（最上层队列）。**
**规则4a. 工作用完整个时间片后，降低其优先级（移入下一个队列）。**
**规则4b. 如果工作在其时间片以内主动释放 CPU， 则优先级不变。**

<img src="./assets/image-20240408082325537-1712535833683-1.png" alt="image-20240408082325537" style="zoom: 67%;" />

![image-20240408082356533](./assets/image-20240408082356533.png)

## （2）问题

1. 饥饿问题：如果系统交互性工作过多，会导致长工作永远无法得到CPU，长工作会被饿死
2. 欺诈问题：欺骗调度程序，比如在时间片结束前调用无关I/O操作，以此保持进程运行在高优先级
3. 程序在不同时间表现不同：计算密集型程序在某些时间也会表现为交互性进程

**规则5. 经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。**

加入规则5后MLFQ的改进：
<img src="./assets/image-20240408083231744.png" alt="image-20240408083231744" style="zoom: 80%;" />

**规则4. (替换规则4a和4b)：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。这个规则旨在规避调度程序欺诈问题。**

# CH9 调度：比例份额



比例份额调度目标：确保每个进程可以拥有一定的CPU资源，而不是优化周转时间和响应时间

## （1）彩票调度法

彩票数代表进程占有资源的份额，若进程拥有编号为a的彩票，则调度程序抽奖抽中a的时候，进程可以占用该资源。

利用随机性：

1. 避免边界情况
2. 随机方法具有轻量化优点，几乎不需要记录状态
3. 具有高性能，可以很快做出决策

## 彩票机制

1. 彩票货币：每个用户拥有自己的货币系统，先把每个用户的进程利用自己的货币系统分配资源，再兑换成全局彩票
2. 彩票转让：可以临时转让自己的彩票给另一个进程，比如客户端可以将彩票转让给服务端，以加速服务端的进程
3. 彩票通胀：进程可以临时提升或降低自己拥有的彩票数量

## 彩票调度的实现

将进程信息（包括拥有的彩票数量）存储到链表当中，做出调度决策前先从彩票总数中抽取随机数作为中奖号码，然后遍历链表，利用计数器找到中奖者。

为了提高算法效率，可以将链表按照彩票数递减排序。

**只有当工作执行非常多的时间片，彩票调度算法才能得到比较公平的调度结果。在工作执行时间片较少的情况下， 彩票调度算法的公平性非常糟糕。**

彩票调度机制的适用领域：有容易确定份额比例的资源情况下，比如虚拟数据中心，虚拟云服务器。VMWare ESX System

# CH10 多处理器调度

# CH11 内存虚拟化：地址空间

用户程序的每个地址都是操作系统虚拟出来的，这样可以方便用户程序操作内存而不需要考虑其他因素（操作系统会给用户程序提供足够的虚拟内存）

## 地址空间

一种典型的安排程序地址空间的方式：

<img src="./assets/image-20240410101650409.png" alt="image-20240410101650409" style="zoom:80%;" />

隔离原则：通过某些机制使得不同进程之间尽量相互独立，例如微内核

## 虚拟化内存目标

### （1）透明

操作系统实现虚拟化的机制应该是加密的，不应该被进程所洞察，否则进程可以通过破解虚拟化内存机制直接操作物理地址

### （2）效率

虚拟化应该尽量高效，追求较低的时间复杂度和空间复杂度，使用TLB硬件方法可以实现高效

### （3）保护

操作系统应该确保每个进程被保护而不会被另外一个进程影响，需要实现内存的隔离，防止出错或者恶意进程的影响



# CH14 内存操作API

## 内存类型

C会分配两种类型的内存：栈内存（自动内存）和堆内存（手动内存）

栈内存：
由编译器隐式管理，比如`int x`，进入函数的时候编译器会自动在栈上开辟空间，在函数退出的时候编译器会自动释放内存。

堆内存：
由程序员手动管理，调用C库函数`malloc()`

## 内存API

`malloc()`调用
`malloc(size_t size)`：分配大小为size的内存给调用者

`calloc()`调用
`calloc(size_t nitems, size_t size)`：nitems是分配的元素个数，size是元素的大小
`calloc(size_t nitems, size_t size) = malloc(size_t nitems * size)`

`realloc()`调用
`realloc(void *ptr, size_t size)`：ptr是原指针，size是新内存空间大小

`free()`调用
`free(x)`释放一个由`malloc()`分配的内存指针x
分配区域的大小不会被用户传入，内存分配库会记录追踪内存分配的过程



`strdup()`函数
复制一个字符串，并且返回包含复制的字符串的内容的地址

```c
char *s = "Hello world!";
char *dup = strdup(s);
```

## 常见错误

### （1）忘记分配内存

### （2）没有分配足够内存

常见与字符串的复制时调用`strlen()`时没有加上预留的末尾一位

### （3）分配的堆内存没有初始化

### （4）忘记释放内存

称为内存泄露，如果忘记释放内存，缓慢泄露的内存会导致内存不足，

### （5）在用完之前释放内存

free了一个指针，但随后又使用了这个指针。注意到`free(p)`后p仍然指向原来的那个地址，但是地址本身不再为p所拥有，而是被操作系统掌握，操作系统可能会将这片内存空间分配给其他指针，这导致对这片地址进行操作可能发生未定义的行为。

### （6）反复释放内存

产生未定义结果

系统中实际存在两级内存管理：操作系统执行的内存管理和堆内管理
进程退出时操作系统会回收所有内存，而堆内存管理大部分由程序员自己管理分配的内存
因此，操作系统的内核必须要确保内存安全

## 底层操作系统对内存分配的支持

**`malloc()`和`free()`不是系统调用，而是C库调用**
`malloc()`等内存分配库是建立在一些系统调用上的，这些系统调用进入操作系统并请求更多内存或释放内存

`brk()`系统调用：改变程序分段的位置，也就是堆结束的位置，需要一个参数即新分断的地址，根据这个新地址决定是增加还是减少堆的大小

`sbrk()`系统调用：参数为增量，作用和`brk()`类似

`mmap()`系统调用：创建匿名内存区域，不与特定文件相关联，而与交换空间相关联

# CH15 机制：地址转换

CPU虚拟化的准则：受限直接访问（LDE，limited direct execution）
程序运行大部分指令直接访问硬件，只在关键点由操作系统介入

## 基于硬件的动态重定位

等价于**基址加界限机制（base and bound）**

每个CPU需要两个硬件寄存器，基址（base）寄存器和界限（bound）寄存器

基址寄存器用于提供偏移量，界限寄存器用于确保偏移后的地址仍然在进程地址空间内，界限寄存器的值通常等于进程的地址空间大小`physical address = virtual address + base`
在15.2中，`base = 32, bound = 16`
基于软件的重定位：由加载程序（loader）接受可执行程序，将地址手动重写到物理内存期望的偏移位置，类似`movl 4000, %eax`
会导致的问题：不提供访问保护，进程可以访问其他进程或操作系统的内存。

**真正的访问保护通常需要硬件支持来实现，因为一些硬件层面检查逻辑很难通过软件层面的机制规避和绕过**

<img src="./assets/image-20240411104314332.png" alt="image-20240411104314332" style="zoom:50%;" />

base + bound = MMU（Memory Management Unit），CPU内存管理单元

操作系统会记录没有使用的空闲内存，利用空闲列表（free list），记录当前没有使用的物理内存的范围

动态重定位必须在特权/内核模式下运行，否则用户程序可以读取并修改基址和界限寄存器

![image-20240411105253841](./assets/image-20240411105253841.png)

操作系统需要介入的情况：

1. 进程创建的时候：操作系统先会从物理内存分配一个槽块给自己，然后检索整个物理内存，根据空闲列表（free list）为新地址空间找到位置，并在空闲列表中标记这块空间为已用
2. 进程终止时：操作系统会回收进程的所有内存给其他进程使用，将这些内存放回空闲列表，并清除相关的数据结构
3. 上下文切换时：保存和恢复基址和界限寄存器，放入进程控制块（PCB）或者进程结构（process structure）当中

![image-20240411112653221](./assets/image-20240411112653221.png)

![image-20240411112726028](./assets/image-20240411112726028.png)

目前机制的缺陷：已分配的内存区域中可能会有空间被浪费（内部碎片）

# CH16 分段

基址+界限寄存器的局限性：栈和堆之间存在大块的空闲空间

分段机制：在 MMU 中引入不止 一个基址和界限寄存器对，而是给地址空间内的每个逻辑段（segment）一对。

逻辑段：代码段，栈段和堆段

分段机制可以提高内存利用率的一个重要原因是因为段和段之间的空闲碎片可以被分配给另外的程序的段。

<img src="./assets/image-20240415083622906.png" alt="image-20240415083622906" style="zoom: 67%;" />

操作系统检查重点：虚拟地址（16.1地址）- 虚拟基址（16.1基址）是否小于等于16.2中分配的段空间
eg.虚拟地址为4200的堆地址，偏移量为4200 - 4K = 104 < 2K，可以访问

访问非法段地址（偏移量超出段大小）：引发段错误（Segmentation Fault）

## 段标识

**显式方式标识**

段内偏移 + 段标识（程序存储在哪个段内）可以确认一个地址在内存空间的确定地址

![image-20240415085255192](./assets/image-20240415085255192.png)

代码实现：

```c
// get top 2 bits of 14-bit VA
Segment = (VirtualAddress & SEG_MASK) >> SEG_SHIFT;
// now get offset
Offset = VirtualAddress & OFFSET_MASK;
if (Offset >= Bounds[Segment])
    RaiseException(PROTECTION_FAULT);
else
    PhysAddr = Base[Segment] + Offset;
	Register = AccessMemory(PhysAddr);
```

其中
`SEG_MASK = 0x3000`是段标识掩码，用于取段标识（取12和13位，其余为0）
`OFFSET_MASK = 0x0FFF`是段内偏移掩码，用于取段内偏移（取除12和13其他位）

**隐式（硬件）方式标识**

如果地址由程序计数器（PC）产生（指令获取）则地址在代码段，若地址基于栈或基址指针，一定在栈段，其余在堆段。

基址指针：存放函数栈帧的起始地址，指向栈区的一个地址。栈帧用于存放函数调用过程产生的栈变量，不同函数有不同的栈帧。所以地址基于基址指针，则一定在栈段.

## 栈

栈段拥有独特的特点：栈是反向增长的，因此需要独特的地址转换机制（需要硬件的支持，硬件需要知道段的增长方向）

![image-20240415103043208](./assets/image-20240415103043208.png)

反向偏移量 = 虚拟地址偏移量 - 最大段地址
虚拟地址偏移量 = 段地址 & 0x0FFF

## 共享

在地址空间之间共享内存段可以节省内存

支持共享需要额外的硬件支持：保护位（protection bit），标识程序能否读写该段或执行其中的代码，若标记为只读，这份代码可以被多个进程共享

![image-20240415110246566](./assets/image-20240415110246566.png)

## 细粒度与粗粒度分段

粗粒度分段：段很少的系统（代码、堆、栈），将地址空间分成较大的粗粒度的块
细粒度分段：允许将地址空间划分为大量的较小的段，如`Multics`

细粒度分段需要硬件支持，并在内存中保存段表（segment table）

## 内存分段的操作系统支持

操作系统在上下文切换的时候会保存和恢复段寄存器的内容

### 内存碎片问题

物理内存会很快充满有许多空闲空间的碎片，这些碎片（由于太小）很难分配给新的段，这被称为**外部碎片问题**

一种解决方案：采用紧凑型物理内存机制，周期性重新安排原有的段，将段的内容复制到连续的内存空间上。缺点：成本高，拷贝段是内存密集型工作，会占用大量的处理器时间

<img src="./assets/image-20240415112226236.png" alt="image-20240415112226236" style="zoom:50%;" />

一种解决方案：空闲列表管理算法，保留大的内存块用于分配，类似的算法包括最优匹配，最坏匹配，首次匹配，伙伴算法

任何算法都无法完全消除外部碎片，算法只能试图减小碎片数

# CH17 空闲空间管理

## 17.1 假设

1. 基本接口：`malloc() free()`此类函数。需要注意，`free()`时不需要告知内存大小，因此传入指针时库必须清楚其对应内存大小
2. 由库管理的空间被称为堆，堆上管理空闲空间的数据结构称为空闲列表，空闲列表包括管理内存区域中所有空闲块的引用
3. 我们主要关心外部碎片（未分配内存或空闲内存的浪费）而不是内部碎片（已分配内存内部利用率问题，通常是程序机制问题）
4. 内存一旦分配给用户，就不能被重定位到其他位置，不能通过紧凑内存来减少碎片（涉及内存的转移）
5. 分配程序所管理的是连续的字节区域，这块区域在整个生命周期内大小固定。

## 17.2 底层机制

### 分割与合并

分隔（splitting）：找到一块可以满足请求的空闲空间，将其分割，第一块返回给用户，第二块留在空 闲列表中

合并（coalescing）：在归还一块空闲内存时，仔细查看要归还的内存块的地址以及邻它的空闲空间块。如果新归还的空间与一个原有空闲块相邻，就将它们合并为一个较大的空闲块。

### 追踪已分配空间的大小

在头块（header）中保存额外的信息，通常头块会在返回的内存块之前，如下图所示：

<img src="./assets/image-20240415135016508.png" alt="image-20240415135016508" style="zoom:67%;" />

得到头块指针的代码实现：

```c
void free(void *ptr) { 
 header_t *hptr = (void *)ptr - sizeof(header_t); 
}
```

`free()`在得到头块的指针后，检查幻数是否符合预期的值（检查内存完整性），计算需要释放的内存的大小

**用户请求N字节内存时，库寻找的是大小为N+头块大小的空闲块**



### 嵌入空闲列表

一个重要步骤是在空闲空间本身当中建立空闲空间的列表

空闲列表节点代码实现：

```c
typedef struct node_t { 
    int size;
    struct node_t *next;
}node_t;
```

初始化堆的代码实现（包括头块的初始化）：

```c
// mmap() returns a pointer to a chunk of free space 
// PROT_READ|PROT_WRITE: 指定映射段的访问权限为可读可写。
// MAP_ANON|MAP_PRIVATE: 表示创建一个匿名映射段,并且是私有的(即只有当前进程可以访问)。
// -1: 表示使用匿名映射,不关联任何文件。0: 表示文件偏移量为0(因为没有关联文件)。
node_t *head = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0);
head->size = 4096 - sizeof(node_t);
head->next = NULL;
```

**空闲块前会有头块用于标记空闲块大小和next指针，可以快速找到和分配空闲块；分配块前会有头块用于标记分配块大小和幻数，可以快速释放分配块**

如果堆中的内存空间耗尽，分配程序会向操作系统申请更大的空间以让堆增长（Unix通常采用sbrk系统调用）

## 17.3 基本策略

### 最优匹配（best fit）

首先遍历整个空闲列表，找到和请求大小一样或更大的空闲块，然后返回这组候选者中最小的一块。是大小最优匹配。
目的：选择最接它用户请求大小的块，从而尽量避免空间浪费。
缺点：遍历需要付出较高的性能代价

### 最差匹配（worst fit）

尝试找最大的空闲块，分割并满足用户 需求后，将剩余的块（很大）加入空闲列表。
目的：在空闲列表中保留较大的块，避免碎片的出现
缺点：由于需要遍历整个链表因此通常开销很高，还会导致过量的碎片

### 首次匹配（first fit）

找到第一个足够大的块，并将请求的空间返回给用户。是时间最优匹配
目的：以快速的速度找到合适的空间
缺点：空闲列表的开头也许会有很多小块，因此建议基于地址排序（即next指针指向最近的空闲块）

### 下次匹配（next fit）

多维护一个指针， 指向上一次查找结束的位置。
目的：对空闲空间的查找操作扩散到整个列表中去，避免对列表开头频繁的分割
性能与首次匹配接近，避免了遍历查找过大的开销

## 17.4 更多策略

### 分离空闲列表

对于经常申请固定大小堆块的某些应用程序，为其建立独立的列表，独立管理这些大小的对象。
目的：可以规避碎片的产生和复杂的列表查找过程，快速分配和释放内存
常见的会为其创建分离空闲列表的对象：锁，文件系统inode（文件描述符）

厚块分配程序是对分离空闲列表思想的一种应用。厚块是一个个基本对象公倍数大小的内存块，并且厚块中的空闲对象保持在预初始化的状态，创建对象时不需要再次初始化，这样可以节省大量初始化和销毁独立对象所造成的开销。

**Bonwick 指出，数据结构的初始化和销毁的开销很大**

### 伙伴系统

为简化合并而打造的分配程序。空闲空间被视为大小为2^N^的空间，因此分配时可以递归分配，释放时也可以递归检查相邻的伙伴是否可以合并成更大的空闲块。

互为伙伴的块只有一位不同。这个性质可以很方便的画出内存块的伙伴树层次。

<img src="./assets/image-20240415144725563.png" alt="image-20240415144725563" style="zoom: 67%;" />

### 高级优化方法

先进分配程序采用复杂数据结构优化查找空闲列表节点的开销。比如**平衡二叉树，伸展树和偏序树**

